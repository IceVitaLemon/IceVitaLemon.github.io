<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.2/css/all.min.css" integrity="sha256-xejo6yLi6vGtAjcMIsY8BHdKsLg7QynVlFMzdQgUuy8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.12.3","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="1. I&#x2F;O Input&#x2F;Output的缩写，简单的理解为数据的输入输出，通常有网络IO、磁盘IO。而IO的类型又分为同步&#x2F;异步IO、阻塞&#x2F;非阻塞I&#x2F;O，组合成具体的IO模型。IO属于操作系统层面上的知识，Java只是在操作系统提供的系统调用上封装了操作接口。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java中的BIO、NIO、AIO">
<meta property="og:url" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/index.html">
<meta property="og:site_name" content="IceVitalemon&#39;s Blog">
<meta property="og:description" content="1. I&#x2F;O Input&#x2F;Output的缩写，简单的理解为数据的输入输出，通常有网络IO、磁盘IO。而IO的类型又分为同步&#x2F;异步IO、阻塞&#x2F;非阻塞I&#x2F;O，组合成具体的IO模型。IO属于操作系统层面上的知识，Java只是在操作系统提供的系统调用上封装了操作接口。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/JVM%20IO%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/IO%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/epoll.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/JAVA_AIO.png">
<meta property="og:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/Proactor%E6%A8%A1%E5%9E%8B.png">
<meta property="article:published_time" content="2022-12-05T06:46:30.000Z">
<meta property="article:modified_time" content="2023-01-05T10:54:38.777Z">
<meta property="article:author" content="Junhao Lin">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/JVM%20IO%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE.png">


<link rel="canonical" href="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/","path":"2022/12/05/Java中的BIO、NIO、AIO/","title":"Java中的BIO、NIO、AIO"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java中的BIO、NIO、AIO | IceVitalemon's Blog</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">IceVitalemon's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-I-x2F-O"><span class="nav-text">1. I&#x2F;O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%98%BB%E5%A1%9E%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text">2. 阻塞和非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-text">3. 同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-Linux%E4%B8%AD%E7%9A%84select%E3%80%81poll%E3%80%81-epoll"><span class="nav-text">4. Linux中的select、poll、 epoll</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-select-x2F-poll"><span class="nav-text">4.1 select&#x2F;poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-epoll"><span class="nav-text">4.2 epoll</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9E%EF%BC%88JAVA-BIO%EF%BC%89"><span class="nav-text">5. 同步阻塞（JAVA BIO）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E6%9C%8D%E5%8A%A1%E7%AB%AFDemo"><span class="nav-text">5.1 服务端Demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E5%AE%A2%E6%88%B7%E7%AB%AFDemo"><span class="nav-text">5.2 客户端Demo</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88JAVA-NIO%EF%BC%89"><span class="nav-text">6. 同步非阻塞（JAVA NIO）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E6%9C%8D%E5%8A%A1%E7%AB%AFDemo"><span class="nav-text">6.1 服务端Demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%AE%A2%E6%88%B7%E7%AB%AFDemo"><span class="nav-text">6.2 客户端Demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E4%BC%98%E5%8C%96%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">6.3 优化线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-Reactor%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">6.4 Reactor设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-1-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">6.4.1 单Reactor单线程模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-2-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">6.4.2 单Reactor多线程模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-4-3-%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">6.4.3 主从Reactor多线程模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%BC%82%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%88JAVA-AIO%EF%BC%89"><span class="nav-text">7. 异步非阻塞（JAVA AIO）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-1-%E6%9C%8D%E5%8A%A1%E5%99%A8Demo"><span class="nav-text">7.1 服务器Demo</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-Proactor%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-text">7.2 Proactor设计模式</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/">
      <img class="site-author-image" itemprop="image" alt="Junhao Lin"
        src="/images/avatar.gif">
    </a>
  <p class="site-author-name" itemprop="name">Junhao Lin</p>
  <div class="site-description" itemprop="description">朝花夕拾</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/IceVitaLemon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;IceVitaLemon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:junhaol0902@outlook.com" title="E-Mail → mailto:junhaol0902@outlook.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/05/Java%E4%B8%AD%E7%9A%84BIO%E3%80%81NIO%E3%80%81AIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Junhao Lin">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IceVitalemon's Blog">
      <meta itemprop="description" content="朝花夕拾">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java中的BIO、NIO、AIO | IceVitalemon's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java中的BIO、NIO、AIO
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-12-05 14:46:30" itemprop="dateCreated datePublished" datetime="2022-12-05T14:46:30+08:00">2022-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-01-05 18:54:38" itemprop="dateModified" datetime="2023-01-05T18:54:38+08:00">2023-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">Java基础知识</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>25 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h3 id="1-I-x2F-O"><a href="#1-I-x2F-O" class="headerlink" title="1. I&#x2F;O"></a>1. I&#x2F;O</h3><blockquote>
<p>Input&#x2F;Output的缩写，简单的理解为<strong>数据的输入输出</strong>，通常有网络IO、磁盘IO。而IO的类型又分为同步&#x2F;异步IO、阻塞&#x2F;非阻塞I&#x2F;O，组合成具体的IO模型。IO属于操作系统层面上的知识，Java只是在操作系统提供的系统调用上封装了操作接口。</p>
</blockquote>
<blockquote>
<p>所有的系统IO都分为两个阶段：等待就绪和操作。以网络IO举例来说，读函数，分为等待网卡可以读和真正的读；同理，写函数，分为等待网卡可以写和真正的写。</p>
<p>需要说明的是等待网卡就绪的阻塞是不使用CPU的，是在<strong>空等</strong>；而真正的读写操作的阻塞是在使用CPU的，真正的在<strong>干活</strong>，而且这个过程非常快，属于内存拷贝，带宽通常在1GB&#x2F;s级别以上，可以理解为基本不耗时。</p>
</blockquote>
<blockquote>
<p>操作系统层面上的IO模型包括</p>
<ul>
<li>同步阻塞IO</li>
<li>同步非阻塞IO</li>
<li>异步非阻塞IO</li>
<li>IO多路复用</li>
<li>信号驱动IO</li>
</ul>
</blockquote>
<p>我们通常在Java中说BIO、NIO、AIO都是在网络IO层面上的，因此处理<strong>大量网络连接、连接输入和输出数据的准备（因为数据的输入和输出需要经过网络，所以时延一定不会短）</strong>就是关键要处理的问题。</p>
<p>在Java中，JVM读写数据都需要经过操作系统内核</p>
<ul>
<li>发送数据：JVM首先要把数据发送给内核，然后内核把数据交给网卡，网卡将数据通过互联网发送至客户端。</li>
<li>接收数据：需要让内核到网卡中查看数据是否已经准备好，如果准备好，则将数据放入内核，内核将数据转交给JVM，JVM再把数据交给我们具体的应用程序；如果没有准备好，通常会被阻塞，也有通过回调方式检测就绪事件（epoll相关）。</li>
</ul>
<img src="JVM IO读写数据.png" alt="image-20221012105409202" style="zoom: 40%;" />

<img src="IO模型对比.png" alt="image-20221012144951976" style="zoom: 50%;" />



<h3 id="2-阻塞和非阻塞"><a href="#2-阻塞和非阻塞" class="headerlink" title="2. 阻塞和非阻塞"></a>2. 阻塞和非阻塞</h3><blockquote>
<p>阻塞和非阻塞的着重点在发起请求后，是否需要等待</p>
</blockquote>
<ul>
<li>阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li>
<li>非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li>
</ul>
<h3 id="3-同步和异步"><a href="#3-同步和异步" class="headerlink" title="3. 同步和异步"></a>3. 同步和异步</h3><blockquote>
<p>同步和异步的着重点在两个任务之间是否需要等待</p>
</blockquote>
<ul>
<li>同步：两个同步任务相互依赖，并且一个任务必须依赖于另一任务的某种方式执行。比如在<code>A-&gt;B</code>事件模型中，需要先完成A才能执行B。换句话说，同步调用中，被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。举个例子，我要去买蛋糕和买菜，但是蛋糕还没做好，我需要等待蛋糕做好之后才能去买菜。</li>
<li>异步：两个异步的任务完全独立，一方的执行不需要等待另一方的执行。换句话说，异步调用中，调用后就返回，不需要等待结果返回，当结果返回的时候，通过回调函数或者其他方式拿着结果进行处理。举例来说，我要去买蛋糕和买菜，但是蛋糕还没做好，店主说留下地址蛋糕做好之后会送上门，那我立马就能去买菜了。</li>
</ul>
<h3 id="4-Linux中的select、poll、-epoll"><a href="#4-Linux中的select、poll、-epoll" class="headerlink" title="4. Linux中的select、poll、 epoll"></a>4. Linux中的select、poll、 epoll</h3><blockquote>
<p>select、poll、 epoll都是Linux内核提供给用户态的多路复用系统调用。进程可以通过一个系统调用函数从内核中获取多个事件。</p>
</blockquote>
<h4 id="4-1-select-x2F-poll"><a href="#4-1-select-x2F-poll" class="headerlink" title="4.1 select&#x2F;poll"></a>4.1 select&#x2F;poll</h4><p>select实现多路复用的方式是，将已连接的Socket都放到一个<strong>文件描述符集合</strong>，然后调用select函数将文件描述符集合<strong>拷贝</strong>到内核中，让内核来检查是否有网络事件产生，检测的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此Socket标记伟可读或可写，接着再把整个文件描述符集合<strong>拷贝</strong>回用户态中，随后用户态还需要通过<strong>遍历</strong>的方法找到可读、可写或可建立连接的Socket，然后再对其处理。</p>
<p>所以，对于select这种方式，需要进行<strong>2次遍历文件描述符集合的操作</strong>，一次是在内核态中，一个是在用户态中，而且还会发生<strong>2次拷贝文件描述符集合的操作</strong>，先从用户空间传入内核空间，由内核修改后，再传出到用户空间中。</p>
<p>select使用固定长度的BitsMap，表示文件描述符集合，而且BitsMap所支持的文件描述符的个数是有限的，在Linux系统中，由内核的FD_SETSIZE限制，默认最大值为<strong>1024</strong>。</p>
<p>poll不再用BitsMap来储存所关注的文件描述符，取而代之用动态数组，以链表形式来组织，突破了select使用BitsMap存储文件描述符个数限制，当然还是会受到系统文件描述符的数量限制。</p>
<p>但是poll和select并没有太大的本质区别，都是使用线性结构储存进程关注的Socket集合，因此都需要遍历文件描述符集合来找到可读或可写的Socket，<strong>时间复杂度为O(n)</strong> ，而且也需要在用户态与内核态之间拷贝文件描述符集合，这种方式随着并发数上来，性能的损耗会呈指数级增长。</p>
<h4 id="4-2-epoll"><a href="#4-2-epoll" class="headerlink" title="4.2 epoll"></a>4.2 epoll</h4><p>epoll在两个方面解决select&#x2F;poll的问题</p>
<p><strong>第一点</strong>，epoll在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的socket通过 <strong>epoll_ctl()</strong> 函数加入到内核中的红黑树里，红黑树是个高效的数据结构，增删查一般时间复杂度是O(logn)，通过维护内核中的这颗红黑树，就不需要像select&#x2F;poll每次操作时都传入整个socket集合，只需要传入一个待检测的socket，减少了内核和用户态间大量的数据拷贝和内存分配。</p>
<p><strong>第二点</strong>，epoll使用<strong>事件驱动的机制</strong>，内核里<strong>维护了一个链表来记录就绪事件</strong>，当某个socket有事件发生时，通过回调函数内核会将其加入到这个就绪事件列表中，当用户调用<strong>epoll_wait()</strong> 函数时，只会返回有事件发生的文件描述符，不需要像select&#x2F;poll一样遍历整个socket集合，大大提高了检测的效率。</p>
<img src="epoll.png" alt="epoll" style="zoom:70%;" />

<p>epoll的方式即使监听的Socket数量越多的时候，效率不会大幅度降低，能够同时监听Socket的数目也非常的多，上限就是系统定义的进程能够打开的最大文件描述符个数。因此epoll被称为解决C10K问题的利器。</p>
<p>epoll 支持两种事件触发模式，分别是<strong>边缘触发（edge-triggered，ET）</strong>和<strong>水平触发（level-triggered，LT）</strong>：</p>
<ul>
<li><strong>边缘触发（edge-triggered，ET）</strong>：当被监控的Socket描述符上有可读事件发生时，<strong>服务器端只会从epoll_wait中苏醒一次</strong>，即使进程没有调用read函数从内核读取数据，也依然只苏醒一次，因为我们程序要保证一次性将内核缓冲区的数据读完。</li>
<li><strong>水平触发（level-triggered，LT）</strong>：当被监控的Socket上有可读事件发生时，<strong>服务器端不断地从epoll_wait中苏醒，直到内核缓冲区数据被read函数读完才结束</strong>，目的时告诉我们有数据要读取（其实从这里就可以看出需要将数据从内核中拷贝到用户态）。</li>
</ul>
<p>如果使用边缘触发模式，I&#x2F;O 事件发生时只会通知一次，而且我们不知道到底能读写多少数据，所以在收到通知后应尽可能地读写数据（需要等待接收到所有的数据），以免错失读写的机会。因此，我们会<strong>循环</strong>从文件描述符读写数据，那么如果文件描述符读写是阻塞的，没有数据可读写时，进程会阻塞在读写函数那里，程序就没办法继续往下执行。所以，<strong>边缘触发模式一般和非阻塞 I&#x2F;O 搭配使用</strong>，程序会一直执行 I&#x2F;O 操作，直到系统调用（如 <code>read</code> 和 <code>write</code>）返回错误，错误类型为 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</p>
<p>一般来说，边缘触发的效率比水平触发的效率要高，因为边缘触发可以减少 epoll_wait 的系统调用次数，系统调用也是有一定的开销的的，毕竟也存在上下文的切换。</p>
<p>select&#x2F;poll 只有水平触发模式，epoll 默认的触发模式是水平触发，但是可以根据应用场景设置为边缘触发模式。</p>
<h3 id="5-同步阻塞（JAVA-BIO）"><a href="#5-同步阻塞（JAVA-BIO）" class="headerlink" title="5. 同步阻塞（JAVA BIO）"></a>5. 同步阻塞（JAVA BIO）</h3><blockquote>
<p>服务端实现模式为一个连接一个线程，所以当有大量连接的时候，线程数可能会超出JVM限制导致应用崩溃，当然可以使用线程池改善，限制线程池的最大线程数以限制最大连接数</p>
</blockquote>
<blockquote>
<p>在服务端视角，如果有N个客户端通讯，想要知道他们有没有发送数据过来，就需要告诉内核到网卡中查看，如果都没有数据过来，这N个线程就都被阻塞了</p>
</blockquote>
<h4 id="5-1-服务端Demo"><a href="#5-1-服务端Demo" class="headerlink" title="5.1 服务端Demo"></a>5.1 服务端Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 可以通过替换为BIOServer::BIODemo、BIOServer::BIOThreadDemo、BIOServer::BIOThreadPoolDemo</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(BIOServer::BIODemo).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BIODemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>), <span class="number">50</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="comment">// serverSocket.accept()代表着去内核中取数据，如果没数据就会被阻塞</span></span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 从socket中获取数据流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">                <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                <span class="comment">// 读操作是同步阻塞的</span></span><br><span class="line">                inputStream.read(data);</span><br><span class="line">                <span class="comment">// 打印获取到的数据</span></span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8));</span><br><span class="line">                <span class="comment">// 将获取到的数据发送回客户端</span></span><br><span class="line">                <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">                <span class="comment">// 写操作是同步阻塞的</span></span><br><span class="line">                out.write(data);</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BIOThreadDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>), <span class="number">50</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> socket;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> clientSocket.getInputStream();</span><br><span class="line">                            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                            inputStream.read(data);</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8));</span><br><span class="line">                            </span><br><span class="line">                            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> clientSocket.getOutputStream();</span><br><span class="line">                            outputStream.write(data);</span><br><span class="line">                            outputStream.close();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">BIOThreadPoolDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">            <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>();</span><br><span class="line">            serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>), <span class="number">50</span>);</span><br><span class="line">            Socket socket;</span><br><span class="line">            <span class="keyword">while</span> ((socket = serverSocket.accept()) != <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">Socket</span> <span class="variable">clientSocket</span> <span class="operator">=</span> socket;</span><br><span class="line">                executorService.submit(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> clientSocket.getInputStream();</span><br><span class="line">                            <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                            inputStream.read(data);</span><br><span class="line"></span><br><span class="line">                            System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(data, StandardCharsets.UTF_8));</span><br><span class="line">                            </span><br><span class="line">                            <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> clientSocket.getOutputStream();</span><br><span class="line">                            outputStream.write(data);</span><br><span class="line">                            outputStream.close();</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-客户端Demo"><a href="#5-2-客户端Demo" class="headerlink" title="5.2 客户端Demo"></a>5.2 客户端Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">        <span class="type">DataInputStream</span> <span class="variable">dataInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(inputStream);</span><br><span class="line">        <span class="type">DataOutputStream</span> <span class="variable">dataOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(outputStream);</span><br><span class="line">        dataOutputStream.writeUTF(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>((response = dataInputStream.readUTF()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            System.out.println(response);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dataInputStream.close();</span><br><span class="line">        dataOutputStream.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="6-同步非阻塞（JAVA-NIO）"><a href="#6-同步非阻塞（JAVA-NIO）" class="headerlink" title="6. 同步非阻塞（JAVA NIO）"></a>6. 同步非阻塞（JAVA NIO）</h3><blockquote>
<p>JAVA NIO由IO多路复用实现，其中Socket主要的接收连接、读和写函数，在等待就绪阶段都是非阻塞的，真正的I&#x2F;O操作是同步阻塞的（消耗CPU但性能非常高）。</p>
</blockquote>
<p>JAVA NIO中有三个重要的概念，分别是缓冲区Buffer、通道Channel、选择器Selector：</p>
<ul>
<li><strong>缓冲区Buffer</strong>：包含一些要写入或者要读出的数据，在NIO库中，所有数据都是用缓冲区处理的。ByteBuffer、IntBuffer、CharBuffer、LongBuffer等都是其实现类。</li>
<li><strong>通道Channel</strong>：Channel是全双工的，可以通过它读取和写入数据。通道和流的不通之处就是通道是双向的，流是单向的（一个流必须是 InputStream 或者 OutputStream 的子类）。</li>
<li><strong>多路复用器Selector</strong>：多路复用器提供选择已经就绪的任务的能力，Selector 能够获取就绪的 Channel（<strong>Linux中select和poll是轮询来获取就绪的事件，但epoll实现是采用回调方式检测就绪事件，而不是轮询</strong>），如果某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 感知，然后通过 SelectionKey 可以获取就绪 Channel 的集合，进行后续的 I&#x2F;O 操作。</li>
</ul>
<h4 id="6-1-服务端Demo"><a href="#6-1-服务端Demo" class="headerlink" title="6.1 服务端Demo"></a>6.1 服务端Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、打开ServerSocketChannel,监听客户端的链接</span></span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//2、绑定监听端口,设置backlog（默认50）:请求传入连接队列的最大长度</span></span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">8888</span>), <span class="number">50</span>);</span><br><span class="line">        <span class="comment">//3、false,设置为非阻塞模式</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//4、创建Selector, Selector是NIO的多路复用器, Selector能够获取注册在它上面就绪的通道Channel(Channel通道发生接收连接、读、写事件)</span></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="comment">//5、注册通道Channel到多路复用器Selector，并说明关注点SelectionKey.OP_ACCEPT，监听ACCEPT事件</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6、不断轮询Selector中就绪的Channel</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">//7、阻塞等待，直到有就绪的Channel，能够设置超时时间</span></span><br><span class="line">            selector.select();</span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();</span><br><span class="line">            <span class="comment">//8、遍历就绪的channel</span></span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                <span class="comment">//9、判断Channel还是否有效</span></span><br><span class="line">                <span class="keyword">if</span> (!key.isValid())&#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(key.isAcceptable())&#123;</span><br><span class="line">                    <span class="comment">//10、Channel接收连接就绪</span></span><br><span class="line">                    <span class="comment">// 通过SelectionKey获取就绪的Channel</span></span><br><span class="line">                    <span class="type">ServerSocketChannel</span> <span class="variable">serverChannel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//11、Selector监听到有新的客户端连接，通过Channel完成TCP三次握手建立连接</span></span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> serverChannel.accept();</span><br><span class="line">                    <span class="comment">//12、设置客户端SocketChannel为非阻塞模式</span></span><br><span class="line">                    <span class="comment">// 注意ServerSocketChannel用于服务器端接收新连接，SocketChannel用于服务器和客户端之间的连接</span></span><br><span class="line">                    clientChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="comment">//13、将客户端的SocketChannel注册到Selector中，并且监听读就绪事件</span></span><br><span class="line">                    clientChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                    <span class="comment">//10、Channel读就绪</span></span><br><span class="line">                    <span class="comment">//11、创建缓冲区Buffer</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.wrap(<span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>]);</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">clientChannel</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//12、从Channel中读取数据到Buffer中</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> clientChannel.read(buffer);</span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="comment">// Buffer中无数据可读，关闭Channel，并且使SelectionKey失效</span></span><br><span class="line">                        key.cancel();</span><br><span class="line">                        clientChannel.close();</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置缓冲区的位置记录为数据的实际长度</span></span><br><span class="line">                        buffer.flip();</span><br><span class="line">                        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(buffer.array(), StandardCharsets.UTF_8));</span><br><span class="line">                        <span class="comment">//13、通过Channel写出数据</span></span><br><span class="line">                        clientChannel.write(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-2-客户端Demo"><a href="#6-2-客户端Demo" class="headerlink" title="6.2 客户端Demo"></a>6.2 客户端Demo</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NIOClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] messages = &#123;</span><br><span class="line">            <span class="string">&quot;message1 from client&quot;</span>,</span><br><span class="line">            <span class="string">&quot;message2 from client&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(<span class="type">SocketChannel</span> <span class="variable">socketChannel</span> <span class="operator">=</span> SocketChannel.open(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8888</span>)))&#123;</span><br><span class="line">            <span class="keyword">for</span>(String message: messages)&#123;</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">writeBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                writeBuffer.put(message.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                writeBuffer.flip();</span><br><span class="line">                <span class="comment">// 这里写是阻塞的</span></span><br><span class="line">                socketChannel.write(writeBuffer);</span><br><span class="line"></span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                <span class="comment">// 这里读是阻塞的</span></span><br><span class="line">                socketChannel.read(readBuffer);</span><br><span class="line">                readBuffer.flip();</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(readBuffer.array(), StandardCharsets.UTF_8));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-3-优化线程模型"><a href="#6-3-优化线程模型" class="headerlink" title="6.3 优化线程模型"></a>6.3 优化线程模型</h4><p>回忆BIO模型，之所以需要多线程，是因为在进行IO操作的时候，没办法知道硬件读写是否就绪，只能阻塞等待，造成大量的<strong>空等</strong>从而阻塞需要进行线程切换（<strong>浪费大量CPU资源在线程上下文切换</strong>）。而NIO通过将通道Channel注册到多路复用器Selector上，达到<strong>只有事件就绪才会执行真正的操作，减少空等的时间，提高CPU的利用率</strong>（CPU一直都在跑，没有等待），只有调用selector.select()时，没有就绪事件才会被阻塞，而这时没有事件就绪说明不需要处理，阻塞等待也是正常的。</p>
<p><strong>NIO将原来BIO的阻塞读写变成了单线程轮询事件（单Reactor单线程模型）</strong>，除了事件的轮询是阻塞的，剩余的IO操作都是纯CPU操作，没有必要开启多线程。并且由于节约线程，当连接数大的时候由线程切换带来的问题也随之解决，为海量连接提供可能。单线程处理I&#x2F;O的效率确实非常高，没有线程切换，只是拼命的读、写、选择事件。<strong>但现在的服务器，一般都是多核处理器，如果能够利用多核心进行I&#x2F;O，无疑对效率会有更大的提高。</strong></p>
<p>分析我们程序的主要功能，包括：</p>
<ul>
<li>网络IO处理，包括accept、read、write等</li>
<li>业务逻辑，通过网络获取到需要的数据之后需要对数据进行处理后返回，这里还会有其他的阻塞IO，如DB操作、RPC等</li>
</ul>
<p>根据功能的线程划分，能够将Reactor线程设计模式分为：</p>
<ul>
<li>单Reactor单线程模型</li>
<li>单Reactor多线程模型</li>
<li>主从Reactor多线程模型</li>
</ul>
<h4 id="6-4-Reactor设计模式"><a href="#6-4-Reactor设计模式" class="headerlink" title="6.4 Reactor设计模式"></a>6.4 Reactor设计模式</h4><blockquote>
<p>Reactor模型是可以处理一个或多个输入源，并通过Service Handler同步的将输入事件（Event）采用多路复用分发给相应的Request Handler（多个）处理的事件驱动模式</p>
</blockquote>
<blockquote>
<p>Reactor模型用于NIO，是一种思想，多线程的思想。其中定义了三个角色：</p>
<ul>
<li><strong>Reactor</strong>：负责监听和分配事件</li>
<li><strong>Acceptor</strong>：处理客户端到来的新连接，并分派请求到Handler链中</li>
<li><strong>Handler</strong>：执行非阻塞读写任务，完成数据读入，处理业务逻辑后，将结果写出</li>
</ul>
</blockquote>
<h5 id="6-4-1-单Reactor单线程模型"><a href="#6-4-1-单Reactor单线程模型" class="headerlink" title="6.4.1 单Reactor单线程模型"></a>6.4.1 单Reactor单线程模型</h5><blockquote>
<p>Reactor、Acceptor、Handler都在一个线程中</p>
<p>优点：模型简单，没有多线程、进程通信、竞争的问题</p>
<p>缺点：无法发挥多核CPU的性能，此外如果业务处理速度比较慢就会影响到程序的高并发性能，任何地方不可用都会导致整个通信模块的不可用</p>
<p>Redis就是这种模型，实际使用的是单线程+队列</p>
</blockquote>
<img src="单Reactor单线程.png" alt="image-20221013095437617" style="zoom:50%;" />

<h5 id="6-4-2-单Reactor多线程模型"><a href="#6-4-2-单Reactor多线程模型" class="headerlink" title="6.4.2 单Reactor多线程模型"></a>6.4.2 单Reactor多线程模型</h5><blockquote>
<p>Reactor主线程中主要负责网络IO相关的处理，包括连接的建立、数据读写，把具体的业务处理逻辑放到线程池中处理</p>
<p>优点：充分利用多核CPU的处理能力，业务阻塞不会影响通信模块</p>
<p>缺点：多线程数据共享和访问的问题，Reactor在单线程中承担所有事件的监听和相应，高并发场景下容易成为性能瓶颈</p>
</blockquote>
<img src="单Reactor多线程.png" alt="image-20221013100405912" style="zoom:53%;" />

<h5 id="6-4-3-主从Reactor多线程模型"><a href="#6-4-3-主从Reactor多线程模型" class="headerlink" title="6.4.3 主从Reactor多线程模型"></a>6.4.3 主从Reactor多线程模型</h5><blockquote>
<p>Reactor主线程中只负责连接的建立，Reactor子线程负责读写数据，在线程池完成业务处理</p>
<p><strong>对连接的处理和读写通常可以选择分开</strong>，这样对于海量连接的注册和读写就可以分发到不同的线程中进行处理，在单线程Reactor模型和单Reactor多线程模型中，虽然read()和write()都是效率比较高的非阻塞函数，但Reactor线程毕竟只占用一个CPU内核，如果面对更高的并发则无能为力。主从Reactor多线程模型就能够解决这个问题。</p>
<p>这种模型在许多项目中广泛使用，包括Nginx主从Reactor多进程模型，Memcached主从多线程，Netty主从多线程模型的支持。</p>
</blockquote>
<img src="主从Reactor多线程.png" alt="image-20221013100926483" style="zoom:52%;" />



<h3 id="7-异步非阻塞（JAVA-AIO）"><a href="#7-异步非阻塞（JAVA-AIO）" class="headerlink" title="7. 异步非阻塞（JAVA AIO）"></a>7. 异步非阻塞（JAVA AIO）</h3><blockquote>
<p>BIO和NIO对于内核来说，都是<strong>应用程序不询问我，我绝不会主动通知</strong>的方式</p>
</blockquote>
<blockquote>
<p>还记得IO操作分为两个阶段：等待就绪和实际操作。在NIO中，等待就绪阶段是不会被阻塞的，但是还是需要实际操作数据，将数据从内核态中拷贝到用户态。AIO解决的就是这个问题，当应用程序发起异步IO之后，内核会完成数据的就绪和将数据从内核态拷贝到用户态中，应用程序并不需要主动发起拷贝动作。</p>
</blockquote>
<blockquote>
<p>AIO采用<strong>订阅-通知</strong>的方式：应用程序向操作系统注册IO监听，然后继续做自己的事情。当操作系统发生IO事件，并且准备好数据后，再主动通知应用程序，触发相应的回调函数。<strong>如果发起异步读写请求，还需要传入数据缓冲区Buffer的地址（用于存放结果数据）等信息，这样内核才能自动帮我们把数据的读写工作完成。</strong></p>
</blockquote>
<blockquote>
<p>AIO也是需要操作系统支持，<strong>微软的windows系统提供了一种异步IO技术IOCP(I&#x2F;O Completion Port，I&#x2F;O完成端口)；Linux下由于没有这种异步IO技术，所以使用的是epoll对异步IO进行模拟</strong></p>
</blockquote>
<blockquote>
<p>NIO中有一个重要的概念多路复用器Selector，负责替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操操作；但是在Java AIO框架中，由于应用程序不是<strong>轮询</strong>方式，而是<strong>订阅-通知</strong>方式，所以不再需要Selector(选择器)了，改由channel通道直接到操作系统注册监听，让操作系统回调实际操作函数。</p>
</blockquote>
<img src="JAVA_AIO.png" alt="image-20221013142450630" style="zoom:50%;" />

<h4 id="7-1-服务器Demo"><a href="#7-1-服务器Demo" class="headerlink" title="7.1 服务器Demo"></a>7.1 服务器Demo</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.17.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousChannelGroup;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AIOServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        BasicConfigurator.configure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">waitObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 对于使用的线程池技术，我一定要多说几句</span></span><br><span class="line"><span class="comment">         * 1、Executors是线程池生成工具，通过这个工具我们可以很轻松的生成“固定大小的线程池”、“调度池”、“可伸缩线程数量的池”。具体请看API Doc</span></span><br><span class="line"><span class="comment">         * 2、当然您也可以通过ThreadPoolExecutor直接生成池。</span></span><br><span class="line"><span class="comment">         * 3、这个线程池是用来得到操作系统的“IO事件通知”的，不是用来进行“得到IO数据后的业务处理的”。要进行后者的操作，您可以再使用一个池(最好不要混用)</span></span><br><span class="line"><span class="comment">         * 4、您也可以不使用线程池(不推荐)，如果决定不使用线程池，直接AsynchronousServerSocketChannel.open()就行了。</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="type">AsynchronousChannelGroup</span> <span class="variable">group</span> <span class="operator">=</span> AsynchronousChannelGroup.withThreadPool(threadPool);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">serverSocket</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open(group);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置要监听的端口“0.0.0.0”代表本机所有IP设备</span></span><br><span class="line">        serverSocket.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">83</span>));</span><br><span class="line">        <span class="comment">//为AsynchronousServerSocketChannel注册监听，注意只是为AsynchronousServerSocketChannel通道注册监听</span></span><br><span class="line">        <span class="comment">//并不包括为 随后客户端和服务器 socketchannel通道注册的监听</span></span><br><span class="line">        serverSocket.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">ServerSocketChannelHandle</span>(serverSocket));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待，以便观察现象(这个和要讲解的原理本身没有任何关系，只是为了保证守护线程不会退出)</span></span><br><span class="line">        <span class="keyword">synchronized</span>(waitObject) &#123;</span><br><span class="line">            waitObject.wait();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个处理器类，专门用来响应 ServerSocketChannel 的事件。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerSocketChannelHandle</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Void&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogFactory.getLog(ServerSocketChannelHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel serverSocketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverSocketChannel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ServerSocketChannelHandle</span><span class="params">(AsynchronousServerSocketChannel serverSocketChannel)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serverSocketChannel = serverSocketChannel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意，我们分别观察 this、socketChannel、attachment三个对象的id。</span></span><br><span class="line"><span class="comment">     * 来观察不同客户端连接到达时，这三个对象的变化，以说明ServerSocketChannelHandle的监听模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel socketChannel, Void attachment)</span> &#123;</span><br><span class="line">        ServerSocketChannelHandle.LOGGER.info(<span class="string">&quot;completed(AsynchronousSocketChannel result, ByteBuffer attachment)&quot;</span>);</span><br><span class="line">        <span class="comment">//每次都要重新注册监听(一次注册，一次响应)，但是由于“文件状态标示符”是独享的，所以不需要担心有“漏掉的”事件</span></span><br><span class="line">        <span class="built_in">this</span>.serverSocketChannel.accept(attachment, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为这个新的socketChannel注册“read”事件，以便操作系统在收到数据并准备好后，主动通知应用程序</span></span><br><span class="line">        <span class="comment">//在这里，由于我们要将这个客户端多次传输的数据累加起来一起处理，所以我们将一个stringbuffer对象作为一个“附件”依附在这个channel上</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">ByteBuffer</span> <span class="variable">readBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">50</span>);</span><br><span class="line">        socketChannel.read(readBuffer, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(), <span class="keyword">new</span> <span class="title class_">SocketChannelReadHandle</span>(socketChannel , readBuffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Void attachment)</span> &#123;</span><br><span class="line">        ServerSocketChannelHandle.LOGGER.info(<span class="string">&quot;failed(Throwable exc, ByteBuffer attachment)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负责对每一个socketChannel的数据获取事件进行监听。&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 重要的说明: 一个socketchannel都会有一个独立工作的SocketChannelReadHandle对象(CompletionHandler接口的实现)，</span></span><br><span class="line"><span class="comment"> * 其中又都将独享一个“文件状态标示”对象FileDescriptor、</span></span><br><span class="line"><span class="comment"> * 一个独立的由程序员定义的Buffer缓存(这里我们使用的是ByteBuffer)、</span></span><br><span class="line"><span class="comment"> * 所以不用担心在服务器端会出现“窜对象”这种情况，因为JAVA AIO框架已经帮您组织好了。&lt;p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 但是最重要的，用于生成channel的对象: AsynchronousChannelProvider是单例模式，无论在哪组socketchannel，</span></span><br><span class="line"><span class="comment"> * 对是一个对象引用(但这没关系，因为您不会直接操作这个AsynchronousChannelProvider对象)。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yinwenjie</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SocketChannelReadHandle</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, StringBuffer&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 日志</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Log</span> <span class="variable">LOGGER</span> <span class="operator">=</span> LogFactory.getLog(SocketChannelReadHandle.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AsynchronousSocketChannel socketChannel;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 专门用于进行这个通道数据缓存操作的ByteBuffer&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 当然，您也可以作为CompletionHandler的attachment形式传入。&lt;br&gt;</span></span><br><span class="line"><span class="comment">     * 这是，在这段示例代码中，attachment被我们用来记录所有传送过来的Stringbuffer了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ByteBuffer byteBuffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SocketChannelReadHandle</span><span class="params">(AsynchronousSocketChannel socketChannel , ByteBuffer byteBuffer)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.socketChannel = socketChannel;</span><br><span class="line">        <span class="built_in">this</span>.byteBuffer = byteBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see java.nio.channels.CompletionHandler#completed(java.lang.Object, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, StringBuffer historyContext)</span> &#123;</span><br><span class="line">        <span class="comment">//如果条件成立，说明客户端主动终止了TCP套接字，这时服务端终止就可以了</span></span><br><span class="line">        <span class="keyword">if</span>(result == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.socketChannel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                SocketChannelReadHandle.LOGGER.error(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;completed(Integer result, Void attachment) : 然后我们来取出通道中准备好的值&quot;</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 实际上，由于我们从Integer result知道了本次channel从操作系统获取数据总长度</span></span><br><span class="line"><span class="comment">         * 所以实际上，我们不需要切换成“读模式”的，但是为了保证编码的规范性，还是建议进行切换。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 另外，无论是JAVA AIO框架还是JAVA NIO框架，都会出现“buffer的总容量”小于“当前从操作系统获取到的总数据量”，</span></span><br><span class="line"><span class="comment">         * 但区别是，JAVA AIO框架中，我们不需要专门考虑处理这样的情况，因为JAVA AIO框架已经帮我们做了处理(做成了多次通知)</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="built_in">this</span>.byteBuffer.flip();</span><br><span class="line">        <span class="type">byte</span>[] contexts = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="built_in">this</span>.byteBuffer.get(contexts, <span class="number">0</span>, result);</span><br><span class="line">        <span class="built_in">this</span>.byteBuffer.clear();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">nowContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(contexts , <span class="number">0</span> , result , <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            historyContext.append(nowContent);</span><br><span class="line">            SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;================目前的传输结果: &quot;</span> + historyContext);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            SocketChannelReadHandle.LOGGER.error(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果条件成立，说明还没有接收到“结束标记”</span></span><br><span class="line">        <span class="keyword">if</span>(historyContext.indexOf(<span class="string">&quot;over&quot;</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=========================================================================</span></span><br><span class="line">        <span class="comment">//          和上篇文章的代码相同，我们以“over”符号作为客户端完整信息的标记</span></span><br><span class="line">        <span class="comment">//=========================================================================</span></span><br><span class="line">        SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;=======收到完整信息，开始处理业务=========&quot;</span>);</span><br><span class="line">        historyContext = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还要继续监听(一次监听一次通知)</span></span><br><span class="line">        <span class="built_in">this</span>.socketChannel.read(<span class="built_in">this</span>.byteBuffer, historyContext, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* (non-Javadoc)</span></span><br><span class="line"><span class="comment">     * @see java.nio.channels.CompletionHandler#failed(java.lang.Throwable, java.lang.Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, StringBuffer historyContext)</span> &#123;</span><br><span class="line">        SocketChannelReadHandle.LOGGER.info(<span class="string">&quot;=====发现客户端异常关闭，服务器将关闭TCP通道&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.socketChannel.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            SocketChannelReadHandle.LOGGER.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-2-Proactor设计模式"><a href="#7-2-Proactor设计模式" class="headerlink" title="7.2 Proactor设计模式"></a>7.2 Proactor设计模式</h4><blockquote>
<p>Reactor是用于非阻塞同步的设计模型，Proactor是用于异步IO的设计模型</p>
</blockquote>
<blockquote>
<p>Proactor整体上与Reactor一致，区别在于Proactor模式将所有IO操作都交给内核处理，工作线程仅仅负责业务逻辑。<strong>Proactor关注的不是就绪事件，而是完成事件，这是区分Reactor模式的关键点</strong>。</p>
<p>Proactor模型主要包括四个角色：</p>
<ul>
<li><strong>Procator Initiator</strong>：负责创建Handler和Procator，并将Procator和Handler（作为回调）都通过Asynchronous operation processor注册到内核</li>
<li><strong>Handler</strong>：执行业务流程的业务处理器</li>
<li><strong>Asynchronous operation processor</strong>：负责处理注册请求，并完成IO操作。完成IO操作后会通知Procator</li>
<li><strong>Procator</strong>：根据不同的事件类型回调不同的handler进行业务处理</li>
</ul>
</blockquote>
<img src="Proactor模型.png" alt="image-20221013172016259" style="zoom:60%;" />



<hr>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/04/nio.html">Java NIO浅析</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/726698#slide-11">JAVA中BIO、NIO、AIO的分析理解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zdreamLife/article/details/124222337">Java I&#x2F;O模型、BIO、Reactor线程模型基本介绍</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u013256816/article/details/115388239">五分钟快速理解 Reactor 模型</a></p>
<p><a href="ttps://pdai.tech/md/java/io/java-io-aio.html">Java AIO - 异步IO详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/26943938">如何深刻理解Reactor和Proactor？</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenssy/p/15526729.html">【死磕 NIO】— Proactor模式是什么？很牛逼吗？</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Qpa0qXxuIM8jrBqDaXmVNA">这次答应我，一举拿下 I&#x2F;O 多路复用！</a></p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/11/02/%E5%85%B3%E4%BA%8E%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%9C%8B%E7%9A%84%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/" rel="prev" title="关于一些好看的写作规范">
                  <i class="fa fa-chevron-left"></i> 关于一些好看的写作规范
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/12/05/Kafka%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" rel="next" title="Kafka知识总结">
                  Kafka知识总结 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2021 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Junhao Lin</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">112k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">6:47</span>
  </span>
</div><script color="0,0,255" opacity="0.5" zIndex="-1" count="99" src="/js/canvas-nest.js"></script>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/pace.js"></script>

  




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"IceVitaLemon","repo":"IceVitaLemon.github.io","client_id":"2bac2f2e44e15b59b869","client_secret":"cde7426c367b8a22029dd71acac79712c5f67459","admin_user":"IceVitaLemon","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d8491a95d8f2979ae242dfd964f65739"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>
